#!/bin/bash
# feature-loop.sh - Full feature workflow: branch -> implement -> E2E test -> PR -> review -> merge
# Generated by ralph-cli for {{projectName}}
# Usage: ./feature-loop.sh <feature-name> [max-iterations] [max-e2e-attempts] [--worktree] [--resume] [--model MODEL] [--review-mode MODE]
#
# Options:
#   --worktree           Use git worktree for isolation (enables parallel execution)
#   --resume             Resume an interrupted loop (reuses existing branch/worktree)
#   --model MODEL        Claude model to use (e.g., opus, sonnet, claude-sonnet-4-5-20250929)
#   --review-mode MODE   Review mode: 'manual' (stop at PR), 'auto' (review, no merge), or 'merge' (review + merge). Default: 'manual'

set -e
set -o pipefail

# Get script directory
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# Load config from ralph.config.cjs if available
if [ -f "$SCRIPT_DIR/../ralph.config.cjs" ]; then
    RALPH_ROOT=$(node -e "console.log(require('$SCRIPT_DIR/../ralph.config.cjs').paths?.root || '.ralph')" 2>/dev/null || echo ".ralph")
    SPEC_DIR=$(node -e "console.log(require('$SCRIPT_DIR/../ralph.config.cjs').paths?.specs || '.ralph/specs')" 2>/dev/null || echo ".ralph/specs")
    PROMPTS_DIR=$(node -e "console.log(require('$SCRIPT_DIR/../ralph.config.cjs').paths?.prompts || '.ralph/prompts')" 2>/dev/null || echo ".ralph/prompts")
    DEFAULT_MODEL=$(node -e "console.log(require('$SCRIPT_DIR/../ralph.config.cjs').loop?.defaultModel || 'sonnet')" 2>/dev/null || echo "sonnet")
    PLANNING_MODEL=$(node -e "console.log(require('$SCRIPT_DIR/../ralph.config.cjs').loop?.planningModel || 'opus')" 2>/dev/null || echo "opus")
    DEFAULT_MAX_ITERATIONS=$(node -e "console.log(require('$SCRIPT_DIR/../ralph.config.cjs').loop?.maxIterations || 10)" 2>/dev/null || echo "10")
    DEFAULT_MAX_E2E=$(node -e "console.log(require('$SCRIPT_DIR/../ralph.config.cjs').loop?.maxE2eAttempts || 5)" 2>/dev/null || echo "5")
elif [ -f "$SCRIPT_DIR/../../ralph.config.cjs" ]; then
    RALPH_ROOT=$(node -e "console.log(require('$SCRIPT_DIR/../../ralph.config.cjs').paths?.root || '.ralph')" 2>/dev/null || echo ".ralph")
    SPEC_DIR=$(node -e "console.log(require('$SCRIPT_DIR/../../ralph.config.cjs').paths?.specs || '.ralph/specs')" 2>/dev/null || echo ".ralph/specs")
    PROMPTS_DIR=$(node -e "console.log(require('$SCRIPT_DIR/../../ralph.config.cjs').paths?.prompts || '.ralph/prompts')" 2>/dev/null || echo ".ralph/prompts")
    DEFAULT_MODEL=$(node -e "console.log(require('$SCRIPT_DIR/../../ralph.config.cjs').loop?.defaultModel || 'sonnet')" 2>/dev/null || echo "sonnet")
    PLANNING_MODEL=$(node -e "console.log(require('$SCRIPT_DIR/../../ralph.config.cjs').loop?.planningModel || 'opus')" 2>/dev/null || echo "opus")
    DEFAULT_MAX_ITERATIONS=$(node -e "console.log(require('$SCRIPT_DIR/../../ralph.config.cjs').loop?.maxIterations || 10)" 2>/dev/null || echo "10")
    DEFAULT_MAX_E2E=$(node -e "console.log(require('$SCRIPT_DIR/../../ralph.config.cjs').loop?.maxE2eAttempts || 5)" 2>/dev/null || echo "5")
else
    # Default paths
    RALPH_ROOT=".ralph"
    SPEC_DIR=".ralph/specs"
    PROMPTS_DIR=".ralph/prompts"
    DEFAULT_MODEL="sonnet"
    PLANNING_MODEL="opus"
    DEFAULT_MAX_ITERATIONS="10"
    DEFAULT_MAX_E2E="5"
fi

# Navigate to project root (parent of .ralph)
cd "$SCRIPT_DIR/../.."

# Parse arguments
USE_WORKTREE=false
RESUME=false
MODEL=""
REVIEW_MODE=""
POSITIONAL=()
while [[ $# -gt 0 ]]; do
    case $1 in
        --worktree)
            USE_WORKTREE=true
            shift
            ;;
        --resume)
            RESUME=true
            shift
            ;;
        --model)
            MODEL="$2"
            shift 2
            ;;
        --review-mode)
            REVIEW_MODE="$2"
            shift 2
            ;;
        *)
            POSITIONAL+=("$1")
            shift
            ;;
    esac
done
set -- "${POSITIONAL[@]}"

# Resolve review mode from CLI > config > default
if [ -z "$REVIEW_MODE" ]; then
    if [ -f "$SCRIPT_DIR/../ralph.config.cjs" ]; then
        REVIEW_MODE_DEFAULT=$(node -e "console.log(require('$SCRIPT_DIR/../ralph.config.cjs').loop?.reviewMode || 'manual')" 2>/dev/null || echo "manual")
    elif [ -f "$SCRIPT_DIR/../../ralph.config.cjs" ]; then
        REVIEW_MODE_DEFAULT=$(node -e "console.log(require('$SCRIPT_DIR/../../ralph.config.cjs').loop?.reviewMode || 'manual')" 2>/dev/null || echo "manual")
    else
        REVIEW_MODE_DEFAULT="manual"
    fi
    REVIEW_MODE="${REVIEW_MODE_DEFAULT}"
fi

# Validate review mode
if [ "$REVIEW_MODE" != "manual" ] && [ "$REVIEW_MODE" != "auto" ] && [ "$REVIEW_MODE" != "merge" ]; then
    echo "ERROR: Invalid review mode: '$REVIEW_MODE'. Allowed values are 'manual', 'auto', or 'merge'." >&2
    exit 1
fi

# Build claude commands
CLAUDE_CMD_OPUS="claude -p --output-format json --dangerously-skip-permissions --model ${PLANNING_MODEL}"
CLAUDE_CMD_IMPL="claude -p --output-format json --dangerously-skip-permissions --model ${MODEL:-$DEFAULT_MODEL}"

# Token tracking
TOKENS_FILE="/tmp/ralph-loop-${1}.tokens"
CLAUDE_OUTPUT="/tmp/ralph-loop-${1}.output"
STATUS_FILE="/tmp/ralph-loop-${1}.status"
FINAL_STATUS_FILE="/tmp/ralph-loop-${1}.final"
PHASES_FILE="/tmp/ralph-loop-${1}.phases"
BASELINE_FILE="/tmp/ralph-loop-${1}.baseline"
SESSIONS_FILE="/tmp/ralph-loop-${1}.sessions"
LOG_FILE="/tmp/ralph-loop-${1}.log"

# Initialize token tracking (4-field format: input|output|cache_create|cache_read)
init_tokens() {
    echo "0|0|0|0" > "$TOKENS_FILE"
    > "$SESSIONS_FILE"
    > "$LOG_FILE"
}

# Extract session result from JSON output.
# Writes human-readable result text to the .log file and captures session_id.
# Usage: extract_session_result <raw_json_file>
# Sets: LAST_SESSION_ID variable
extract_session_result() {
    local raw_file="$1"
    LAST_SESSION_ID=""
    if [ ! -f "$raw_file" ]; then return; fi

    local result
    result=$(python3 -c "
import json, sys
try:
    data = json.load(open(sys.argv[1]))
    if not isinstance(data, list): data = [data]
    for entry in reversed(data):
        if isinstance(entry, dict) and entry.get('type') == 'result':
            print(entry.get('session_id', ''))
            break
except Exception:
    pass
" "$raw_file" 2>/dev/null) || true

    LAST_SESSION_ID="$result"

    if [ -n "$LAST_SESSION_ID" ]; then
        echo "$LAST_SESSION_ID" >> "$SESSIONS_FILE"
    fi

    # Extract human-readable result text and append to log
    python3 -c "
import json, sys
try:
    data = json.load(open(sys.argv[1]))
    if not isinstance(data, list): data = [data]
    for entry in data:
        if isinstance(entry, dict) and entry.get('type') == 'result':
            text = entry.get('result', '')
            if text:
                print(text)
except Exception:
    pass
" "$raw_file" >> "$LOG_FILE" 2>/dev/null || true
}

# Accumulate tokens from a session JSONL file into the .tokens file.
# Usage: accumulate_tokens_from_session <session_id>
accumulate_tokens_from_session() {
    local session_id="$1"
    if [ -z "$session_id" ]; then return; fi

    # Find the JSONL file for this session
    local jsonl_file=""
    for f in ~/.claude/projects/*/"${session_id}.jsonl"; do
        if [ -f "$f" ]; then
            jsonl_file="$f"
            break
        fi
    done

    if [ -z "$jsonl_file" ]; then
        echo "WARNING: Could not find JSONL for session $session_id" >&2
        return
    fi

    # Extract and sum token usage from all assistant messages
    local session_tokens
    session_tokens=$(python3 -c "
import json, sys
totals = {'input': 0, 'output': 0, 'cache_create': 0, 'cache_read': 0}
for line in open(sys.argv[1]):
    try:
        obj = json.loads(line)
        if obj.get('type') != 'assistant':
            continue
        usage = obj.get('message', {}).get('usage', {})
        if not usage:
            continue
        totals['input'] += usage.get('input_tokens', 0)
        totals['output'] += usage.get('output_tokens', 0)
        totals['cache_create'] += usage.get('cache_creation_input_tokens', 0)
        totals['cache_read'] += usage.get('cache_read_input_tokens', 0)
    except (json.JSONDecodeError, AttributeError):
        continue
print(f\"{totals['input']}|{totals['output']}|{totals['cache_create']}|{totals['cache_read']}\")
" "$jsonl_file" 2>/dev/null) || true

    if [ -z "$session_tokens" ]; then return; fi

    # Parse session tokens
    local s_input s_output s_cache_create s_cache_read
    s_input=$(echo "$session_tokens" | cut -d'|' -f1)
    s_output=$(echo "$session_tokens" | cut -d'|' -f2)
    s_cache_create=$(echo "$session_tokens" | cut -d'|' -f3)
    s_cache_read=$(echo "$session_tokens" | cut -d'|' -f4)

    # Read current totals
    local current c_input c_output c_cache_create c_cache_read
    if [ -f "$TOKENS_FILE" ]; then
        current=$(cat "$TOKENS_FILE")
        c_input=$(echo "$current" | cut -d'|' -f1)
        c_output=$(echo "$current" | cut -d'|' -f2)
        c_cache_create=$(echo "$current" | cut -d'|' -f3)
        c_cache_read=$(echo "$current" | cut -d'|' -f4)
        [[ "$c_input" =~ ^[0-9]+$ ]] || c_input=0
        [[ "$c_output" =~ ^[0-9]+$ ]] || c_output=0
        [[ "$c_cache_create" =~ ^[0-9]+$ ]] || c_cache_create=0
        [[ "$c_cache_read" =~ ^[0-9]+$ ]] || c_cache_read=0
    else
        c_input=0; c_output=0; c_cache_create=0; c_cache_read=0
    fi

    # Accumulate
    echo "$((c_input + s_input))|$((c_output + s_output))|$((c_cache_create + s_cache_create))|$((c_cache_read + s_cache_read))" > "$TOKENS_FILE"
}

# Action inbox: write request file if not already present
write_action_request() {
    local action_file="/tmp/ralph-loop-${FEATURE}.action.json"
    if [ -f "$action_file" ]; then
        echo "WARNING: Action request file already exists, skipping write: $action_file" >&2
        return 0
    fi
    cat > "$action_file" << 'EOF'
{
  "id": "post_pr_choice",
  "prompt": "Loop complete. What would you like to do?",
  "choices": [
    {"id": "done", "label": "Done â€” end loop"},
    {"id": "merge_local", "label": "Merge back to main locally"},
    {"id": "keep_branch", "label": "Keep branch as-is"},
    {"id": "discard", "label": "Discard this work"}
  ],
  "default": "done"
}
EOF
    echo "Action request written: $action_file"
}

# Action inbox: poll for reply file, fallback to default after 15 minutes
poll_action_reply() {
    local action_file="/tmp/ralph-loop-${FEATURE}.action.json"
    local reply_file="/tmp/ralph-loop-${FEATURE}.action.reply.json"
    local default_choice="keep_branch"
    local timeout=900  # 15 minutes in seconds
    local elapsed=0

    # Read default from action file if present
    if [ -f "$action_file" ]; then
        local parsed_default
        parsed_default=$(node -e "try { const d=require('fs').readFileSync(process.argv[1],'utf8'); console.log(JSON.parse(d).default||'keep_branch'); } catch(e) { console.log('keep_branch'); }" "$action_file" 2>/dev/null || echo "keep_branch")
        if [ -n "$parsed_default" ]; then
            default_choice="$parsed_default"
        fi
    fi

    while [ $elapsed -lt $timeout ]; do
        if [ -f "$reply_file" ]; then
            local choice
            choice=$(node -e "try { const d=require('fs').readFileSync(process.argv[1],'utf8'); console.log(JSON.parse(d).choice||''); } catch(e) { console.log(''); }" "$reply_file" 2>/dev/null || echo "")
            if [ -n "$choice" ]; then
                echo "User selected: $choice" >&2
                # Cleanup both files
                rm -f "$action_file" "$reply_file" 2>/dev/null || true
                echo "$choice"
                return 0
            fi
        fi
        sleep 1
        elapsed=$((elapsed + 1))
    done

    # Timeout: use default
    echo "Action reply timeout after ${timeout}s, using default: $default_choice" >&2
    rm -f "$action_file" "$reply_file" 2>/dev/null || true
    echo "$default_choice"
}

# Initialize tokens
init_tokens

# Phase tracking helpers
write_phase_start() {
    local phase_id="$1"
    local timestamp=$(date +%s)
    echo "${phase_id}|started|${timestamp}|" >> "$PHASES_FILE"
}

write_phase_end() {
    local phase_id="$1"
    local status="$2"  # success, failed, skipped
    local timestamp=$(date +%s)

    # Find the last line for this phase and update it
    if [ -f "$PHASES_FILE" ]; then
        # Get all lines except the last matching phase line
        grep -v "^${phase_id}|started|" "$PHASES_FILE" > "${PHASES_FILE}.tmp" 2>/dev/null || true
        # Find the start timestamp from the original file
        local start_ts=$(grep "^${phase_id}|started|" "$PHASES_FILE" | tail -1 | cut -d'|' -f3)
        # Write updated line
        echo "${phase_id}|${status}|${start_ts}|${timestamp}" >> "${PHASES_FILE}.tmp"
        mv "${PHASES_FILE}.tmp" "$PHASES_FILE"
    fi
}

# Initialize phase tracking
> "$PHASES_FILE"

FEATURE="${1:?Usage: ./feature-loop.sh <feature-name> [max-iterations] [max-e2e-attempts] [--worktree] [--resume] [--model MODEL]}"
MAX_ITERATIONS="${2:-$DEFAULT_MAX_ITERATIONS}"
MAX_E2E_ATTEMPTS="${3:-$DEFAULT_MAX_E2E}"
ITERATION=0

# Paths
SPEC_FILE="$SPEC_DIR/${FEATURE}.md"
PLAN_FILE="$SPEC_DIR/${FEATURE}-implementation-plan.md"
BRANCH="feat/${FEATURE}"
APP_DIR="$(pwd)"

echo "=========================================="
echo "Ralph Loop: $FEATURE"
echo "Spec: $SPEC_FILE"
echo "Plan: $PLAN_FILE"
echo "Branch: $BRANCH"
echo "App dir: $APP_DIR"
echo "Worktree mode: $USE_WORKTREE"
echo "Resume mode: $RESUME"
echo "Review mode: $REVIEW_MODE"
echo "Model (planning): $PLANNING_MODEL"
echo "Model (impl): ${MODEL:-$DEFAULT_MODEL}"
echo "Max iterations: $MAX_ITERATIONS"
echo "Max E2E attempts: $MAX_E2E_ATTEMPTS"
echo "=========================================="

# Phase 1: Validate spec exists
if [ ! -f "$SPEC_FILE" ]; then
    echo "ERROR: Spec file not found: $SPEC_FILE"
    echo "Create the spec first: ralph new $FEATURE"
    exit 1
fi

# Phase 2: Create branch if not exists
CURRENT_BRANCH=$(git branch --show-current)
if [ "$CURRENT_BRANCH" != "$BRANCH" ]; then
    if git rev-parse --verify "$BRANCH" >/dev/null 2>&1; then
        if [ "$RESUME" = true ]; then
            echo "Resuming on existing branch: $BRANCH"
            git checkout "$BRANCH"
        else
            echo "Creating/switching to branch: $BRANCH"
            git checkout -B "$BRANCH" main 2>/dev/null || git checkout -B "$BRANCH" master
        fi
    else
        echo "Creating branch: $BRANCH"
        git checkout -b "$BRANCH" main 2>/dev/null || git checkout -b "$BRANCH" master
    fi
else
    echo "Already on branch: $BRANCH"
fi

# Create output file for monitoring
touch "$CLAUDE_OUTPUT"

# Record baseline commit
if git rev-parse --git-dir > /dev/null 2>&1; then
    BASELINE_COMMIT=$(git rev-parse HEAD 2>/dev/null || echo "")
    if [ -n "$BASELINE_COMMIT" ]; then
        echo "$BASELINE_COMMIT" > "$BASELINE_FILE"
        echo "Baseline commit: $BASELINE_COMMIT"
    fi
fi

# Phase 3: Planning (if no implementation plan exists)
if [ ! -f "$PLAN_FILE" ]; then
    echo "======================== PLANNING PHASE ========================"
    write_phase_start "planning"
    export FEATURE APP_DIR SPEC_DIR PROMPTS_DIR
    cat "$PROMPTS_DIR/PROMPT_feature.md" | envsubst | $CLAUDE_CMD_OPUS 2>&1 | tee "${CLAUDE_OUTPUT}.raw" || {
        echo "ERROR: Planning phase failed"
        write_phase_end "planning" "failed"
        exit 1
    }
    extract_session_result "${CLAUDE_OUTPUT}.raw"
    accumulate_tokens_from_session "$LAST_SESSION_ID"
    write_phase_end "planning" "success"
else
    echo "Plan file exists, skipping planning phase"
    write_phase_start "planning"
    write_phase_end "planning" "skipped"
fi

# Phase 4: Implementation loop
echo "======================== IMPLEMENTATION PHASE ========================"
write_phase_start "implementation"
IMPL_SUCCESS=true
while true; do
    if [ $ITERATION -ge $MAX_ITERATIONS ]; then
        echo "Reached max iterations: $MAX_ITERATIONS"
        IMPL_SUCCESS=false
        write_phase_end "implementation" "failed"
        exit 1
    fi

    ITERATION=$((ITERATION + 1))
    echo "$ITERATION|$MAX_ITERATIONS|$(date +%s)" > "$STATUS_FILE"
    echo "------------------------ Iteration $ITERATION ------------------------"

    # Check if implementation tasks are done
    PENDING_IMPL=$({ grep "^- \[ \]" "$PLAN_FILE" 2>/dev/null || true; } | { grep -v "E2E:" || true; } | wc -l | tr -d ' ')
    if [ "$PENDING_IMPL" -eq 0 ]; then
        echo "All implementation tasks completed!"
        break
    fi

    echo "Pending implementation tasks: $PENDING_IMPL"
    export FEATURE APP_DIR SPEC_DIR PROMPTS_DIR
    cat "$PROMPTS_DIR/PROMPT.md" | envsubst | $CLAUDE_CMD_IMPL 2>&1 | tee "${CLAUDE_OUTPUT}.raw" || true
    extract_session_result "${CLAUDE_OUTPUT}.raw"
    accumulate_tokens_from_session "$LAST_SESSION_ID"

    sleep 2
done
if [ "$IMPL_SUCCESS" = true ]; then
    write_phase_end "implementation" "success"
fi

# Phase 5: E2E Testing
echo "======================== E2E TESTING PHASE ========================"
E2E_TOTAL=$({ grep "^- \[.\].*E2E:" "$PLAN_FILE" 2>/dev/null || true; } | wc -l | tr -d ' ')
if [ "$E2E_TOTAL" -eq 0 ]; then
    echo "No E2E scenarios defined, skipping E2E phase."
    write_phase_start "e2e_testing"
    write_phase_end "e2e_testing" "skipped"
else
    write_phase_start "e2e_testing"
    E2E_SUCCESS=false
    E2E_ATTEMPT=0
    while [ $E2E_ATTEMPT -lt $MAX_E2E_ATTEMPTS ]; do
        E2E_ATTEMPT=$((E2E_ATTEMPT + 1))
        echo "------------------------ E2E Attempt $E2E_ATTEMPT of $MAX_E2E_ATTEMPTS ------------------------"

        export FEATURE APP_DIR SPEC_DIR PROMPTS_DIR
        cat "$PROMPTS_DIR/PROMPT_e2e.md" | envsubst | $CLAUDE_CMD_IMPL 2>&1 | tee "${CLAUDE_OUTPUT}.raw" || true
        extract_session_result "${CLAUDE_OUTPUT}.raw"
        accumulate_tokens_from_session "$LAST_SESSION_ID"

        # Check if all E2E tests passed
        E2E_FAILED=$({ grep "^- \[ \].*E2E:.*FAILED" "$PLAN_FILE" 2>/dev/null || true; } | wc -l | tr -d ' ')
        E2E_PENDING=$({ grep "^- \[ \].*E2E:" "$PLAN_FILE" 2>/dev/null || true; } | { grep -v "FAILED" || true; } | wc -l | tr -d ' ')

        if [ "$E2E_FAILED" -eq 0 ] && [ "$E2E_PENDING" -eq 0 ]; then
            echo "All E2E tests passed!"
            E2E_SUCCESS=true
            break
        fi

        if [ $E2E_ATTEMPT -lt $MAX_E2E_ATTEMPTS ]; then
            echo "E2E tests have failures. Running fix iteration..."
            cat "$PROMPTS_DIR/PROMPT.md" | envsubst | $CLAUDE_CMD_IMPL 2>&1 | tee "${CLAUDE_OUTPUT}.raw" || true
            extract_session_result "${CLAUDE_OUTPUT}.raw"
            accumulate_tokens_from_session "$LAST_SESSION_ID"
        fi
    done

    if [ "$E2E_SUCCESS" = true ]; then
        write_phase_end "e2e_testing" "success"
    else
        write_phase_end "e2e_testing" "failed"
    fi
fi

# Phase 6: Spec Verification
echo "======================== SPEC VERIFICATION PHASE ========================"
write_phase_start "verification"
export FEATURE APP_DIR SPEC_DIR PROMPTS_DIR
VERIFY_STATUS="success"
if ! cat "$PROMPTS_DIR/PROMPT_verify.md" | envsubst | $CLAUDE_CMD_OPUS 2>&1 | tee "${CLAUDE_OUTPUT}.raw"; then
    VERIFY_STATUS="failed"
fi
extract_session_result "${CLAUDE_OUTPUT}.raw"
accumulate_tokens_from_session "$LAST_SESSION_ID"
write_phase_end "verification" "$VERIFY_STATUS"

# Phase 7: PR and Review
echo "======================== PR & REVIEW PHASE ========================"
write_phase_start "pr_review"
export FEATURE APP_DIR SPEC_DIR PROMPTS_DIR
PR_STATUS="success"
MAX_REVIEW_ATTEMPTS=3

# Check for review approval in stdout or latest PR comment.
# Returns 0 (true) if approved, 1 (false) otherwise.
check_review_approved() {
    local output_file="$1"

    # Primary: check stdout for explicit verdict line
    if grep -qi "VERDICT:.*APPROVED" "$output_file" 2>/dev/null; then
        # Make sure it's not "NOT APPROVED"
        if ! grep -qi "VERDICT:.*NOT APPROVED" "$output_file" 2>/dev/null; then
            return 0
        fi
    fi

    # Fallback: check the latest PR comment for approval signal
    local latest_comment
    latest_comment=$(gh pr view "$BRANCH" --json comments --jq '.comments[-1].body' 2>/dev/null || echo "")
    if echo "$latest_comment" | grep -qi "VERDICT:.*APPROVED\|Verdict:.*APPROVED" 2>/dev/null; then
        if ! echo "$latest_comment" | grep -qi "NOT APPROVED" 2>/dev/null; then
            return 0
        fi
    fi

    return 1
}

if [ "$REVIEW_MODE" = "manual" ]; then
    if ! cat "$PROMPTS_DIR/PROMPT_review_manual.md" | envsubst | $CLAUDE_CMD_OPUS 2>&1 | tee "${CLAUDE_OUTPUT}.raw"; then
        PR_STATUS="failed"
    fi
    extract_session_result "${CLAUDE_OUTPUT}.raw"
    accumulate_tokens_from_session "$LAST_SESSION_ID"

elif [ "$REVIEW_MODE" = "merge" ]; then
    # Merge mode: create PR, iterate review+fixes until approved, then merge
    REVIEW_ATTEMPT=0
    REVIEW_APPROVED=false
    while [ $REVIEW_ATTEMPT -lt $MAX_REVIEW_ATTEMPTS ]; do
        REVIEW_ATTEMPT=$((REVIEW_ATTEMPT + 1))
        echo "--- Review attempt $REVIEW_ATTEMPT of $MAX_REVIEW_ATTEMPTS ---"
        cat "$PROMPTS_DIR/PROMPT_review_merge.md" | envsubst | $CLAUDE_CMD_OPUS 2>&1 | tee "${CLAUDE_OUTPUT}.raw" || true
        extract_session_result "${CLAUDE_OUTPUT}.raw"
        accumulate_tokens_from_session "$LAST_SESSION_ID"

        # Check stdout and PR comment for approval
        if check_review_approved "${CLAUDE_OUTPUT}.raw"; then
            echo "Review approved!"
            REVIEW_APPROVED=true
            break
        fi

        if [ $REVIEW_ATTEMPT -lt $MAX_REVIEW_ATTEMPTS ]; then
            echo "Review found issues. Running fix iteration..."
            echo "Fix the issues found in the code review above. Run git diff main to see the current changes, then:
1. Fix each issue referenced in the review
2. Run tests: npm test
3. Commit and push the fixes
Do NOT propose completion options or ask interactive questions. Just fix, test, commit, push." | $CLAUDE_CMD_IMPL 2>&1 | tee "${CLAUDE_OUTPUT}.raw" || true
            extract_session_result "${CLAUDE_OUTPUT}.raw"
            accumulate_tokens_from_session "$LAST_SESSION_ID"
        fi
    done
    if [ "$REVIEW_APPROVED" != true ]; then
        echo "Review not approved after $MAX_REVIEW_ATTEMPTS attempts."
        PR_STATUS="failed"
    fi

else
    # Auto mode: create PR, iterate review+fixes until approved (no merge)
    REVIEW_ATTEMPT=0
    REVIEW_APPROVED=false
    while [ $REVIEW_ATTEMPT -lt $MAX_REVIEW_ATTEMPTS ]; do
        REVIEW_ATTEMPT=$((REVIEW_ATTEMPT + 1))
        echo "--- Review attempt $REVIEW_ATTEMPT of $MAX_REVIEW_ATTEMPTS ---"
        cat "$PROMPTS_DIR/PROMPT_review_auto.md" | envsubst | $CLAUDE_CMD_OPUS 2>&1 | tee "${CLAUDE_OUTPUT}.raw" || true
        extract_session_result "${CLAUDE_OUTPUT}.raw"
        accumulate_tokens_from_session "$LAST_SESSION_ID"

        # Check stdout and PR comment for approval
        if check_review_approved "${CLAUDE_OUTPUT}.raw"; then
            echo "Review approved!"
            REVIEW_APPROVED=true
            break
        fi

        if [ $REVIEW_ATTEMPT -lt $MAX_REVIEW_ATTEMPTS ]; then
            echo "Review found issues. Running fix iteration..."
            echo "Fix the issues found in the code review above. Run git diff main to see the current changes, then:
1. Fix each issue referenced in the review
2. Run tests: npm test
3. Commit and push the fixes
Do NOT propose completion options or ask interactive questions. Just fix, test, commit, push." | $CLAUDE_CMD_IMPL 2>&1 | tee "${CLAUDE_OUTPUT}.raw" || true
            extract_session_result "${CLAUDE_OUTPUT}.raw"
            accumulate_tokens_from_session "$LAST_SESSION_ID"
        fi
    done
    if [ "$REVIEW_APPROVED" != true ]; then
        echo "Review not approved after $MAX_REVIEW_ATTEMPTS attempts. PR ready for manual review."
    fi
fi
write_phase_end "pr_review" "$PR_STATUS"

# Phase 7.5: Post-completion action request
echo "======================== ACTION REQUEST PHASE ========================"
write_action_request
CHOSEN_ACTION=$(poll_action_reply)
echo "User chose: $CHOSEN_ACTION"

# Dispatch based on user choice
case "$CHOSEN_ACTION" in
    done)
        echo "Loop complete. Exiting."
        ;;
    merge_local)
        echo "Merging back to main locally..."
        git checkout main 2>/dev/null || git checkout master
        git merge --squash "$BRANCH" && git commit -m "feat($FEATURE): squash merge from $BRANCH"
        echo "Merged. You can delete the branch with: git branch -D $BRANCH"
        ;;
    discard)
        echo "Discarding work on branch $BRANCH..."
        git checkout main 2>/dev/null || git checkout master
        git branch -D "$BRANCH" 2>/dev/null || echo "Branch $BRANCH not found locally."
        ;;
    keep_branch|*)
        echo "Keeping branch $BRANCH as-is."
        ;;
esac

# Persist final status for TUI summaries
if ! echo "$ITERATION|$MAX_ITERATIONS|$(date +%s)|done" > "$FINAL_STATUS_FILE"; then
    echo "WARNING: Failed to write final status file: $FINAL_STATUS_FILE" >&2
fi

# Cleanup temp files
rm -f "$STATUS_FILE" 2>/dev/null || true
rm -f "/tmp/ralph-loop-${FEATURE}.output" 2>/dev/null || true

# Print final token usage
if [ -f "/tmp/ralph-loop-${FEATURE}.tokens" ]; then
    echo ""
    echo "=========================================="
    echo "Final Token Usage:"
    cat "/tmp/ralph-loop-${FEATURE}.tokens" | awk -F'|' '{printf "  Input: %s tokens\n  Output: %s tokens\n  Total: %s tokens\n", $1, $2, $1+$2}'
    echo "=========================================="
fi

echo "=========================================="
echo "Ralph loop completed: $FEATURE"
echo "=========================================="
