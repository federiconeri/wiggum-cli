#!/bin/bash
# feature-loop.sh - Full feature workflow: branch -> implement -> E2E test -> PR -> review -> merge
# Generated by ralph-cli for {{projectName}}
# Usage: ./feature-loop.sh <feature-name> [max-iterations] [max-e2e-attempts] [--worktree] [--resume] [--model MODEL]
#
# Options:
#   --worktree       Use git worktree for isolation (enables parallel execution)
#   --resume         Resume an interrupted loop (reuses existing branch/worktree)
#   --model MODEL    Claude model to use (e.g., opus, sonnet, claude-sonnet-4-5-20250514)

set -e
set -o pipefail

# Get script directory
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# Load config from ralph.config.cjs if available
if [ -f "$SCRIPT_DIR/../ralph.config.cjs" ]; then
    RALPH_ROOT=$(node -e "console.log(require('$SCRIPT_DIR/../ralph.config.cjs').paths?.root || '.ralph')" 2>/dev/null || echo ".ralph")
    SPEC_DIR=$(node -e "console.log(require('$SCRIPT_DIR/../ralph.config.cjs').paths?.specs || '.ralph/specs')" 2>/dev/null || echo ".ralph/specs")
    PROMPTS_DIR=$(node -e "console.log(require('$SCRIPT_DIR/../ralph.config.cjs').paths?.prompts || '.ralph/prompts')" 2>/dev/null || echo ".ralph/prompts")
    DEFAULT_MODEL=$(node -e "console.log(require('$SCRIPT_DIR/../ralph.config.cjs').loop?.defaultModel || 'sonnet')" 2>/dev/null || echo "sonnet")
    PLANNING_MODEL=$(node -e "console.log(require('$SCRIPT_DIR/../ralph.config.cjs').loop?.planningModel || 'opus')" 2>/dev/null || echo "opus")
    DEFAULT_MAX_ITERATIONS=$(node -e "console.log(require('$SCRIPT_DIR/../ralph.config.cjs').loop?.maxIterations || 10)" 2>/dev/null || echo "10")
    DEFAULT_MAX_E2E=$(node -e "console.log(require('$SCRIPT_DIR/../ralph.config.cjs').loop?.maxE2eAttempts || 5)" 2>/dev/null || echo "5")
elif [ -f "$SCRIPT_DIR/../../ralph.config.cjs" ]; then
    RALPH_ROOT=$(node -e "console.log(require('$SCRIPT_DIR/../../ralph.config.cjs').paths?.root || '.ralph')" 2>/dev/null || echo ".ralph")
    SPEC_DIR=$(node -e "console.log(require('$SCRIPT_DIR/../../ralph.config.cjs').paths?.specs || '.ralph/specs')" 2>/dev/null || echo ".ralph/specs")
    PROMPTS_DIR=$(node -e "console.log(require('$SCRIPT_DIR/../../ralph.config.cjs').paths?.prompts || '.ralph/prompts')" 2>/dev/null || echo ".ralph/prompts")
    DEFAULT_MODEL=$(node -e "console.log(require('$SCRIPT_DIR/../../ralph.config.cjs').loop?.defaultModel || 'sonnet')" 2>/dev/null || echo "sonnet")
    PLANNING_MODEL=$(node -e "console.log(require('$SCRIPT_DIR/../../ralph.config.cjs').loop?.planningModel || 'opus')" 2>/dev/null || echo "opus")
    DEFAULT_MAX_ITERATIONS=$(node -e "console.log(require('$SCRIPT_DIR/../../ralph.config.cjs').loop?.maxIterations || 10)" 2>/dev/null || echo "10")
    DEFAULT_MAX_E2E=$(node -e "console.log(require('$SCRIPT_DIR/../../ralph.config.cjs').loop?.maxE2eAttempts || 5)" 2>/dev/null || echo "5")
else
    # Default paths
    RALPH_ROOT=".ralph"
    SPEC_DIR=".ralph/specs"
    PROMPTS_DIR=".ralph/prompts"
    DEFAULT_MODEL="sonnet"
    PLANNING_MODEL="opus"
    DEFAULT_MAX_ITERATIONS="10"
    DEFAULT_MAX_E2E="5"
fi

# Navigate to project root (parent of .ralph)
cd "$SCRIPT_DIR/../.."

# Parse arguments
USE_WORKTREE=false
RESUME=false
MODEL=""
POSITIONAL=()
while [[ $# -gt 0 ]]; do
    case $1 in
        --worktree)
            USE_WORKTREE=true
            shift
            ;;
        --resume)
            RESUME=true
            shift
            ;;
        --model)
            MODEL="$2"
            shift 2
            ;;
        *)
            POSITIONAL+=("$1")
            shift
            ;;
    esac
done
set -- "${POSITIONAL[@]}"

# Build claude commands
CLAUDE_CMD_OPUS="claude -p --dangerously-skip-permissions --model ${PLANNING_MODEL}"
CLAUDE_CMD_IMPL="claude -p --dangerously-skip-permissions --model ${MODEL:-$DEFAULT_MODEL}"

# Token tracking
TOKENS_FILE="/tmp/ralph-loop-${1}.tokens"
CLAUDE_OUTPUT="/tmp/ralph-loop-${1}.output"
STATUS_FILE="/tmp/ralph-loop-${1}.status"
FINAL_STATUS_FILE="/tmp/ralph-loop-${1}.final"

# Initialize token tracking
init_tokens() {
    echo "0|0" > "$TOKENS_FILE"
}

# Parse and accumulate tokens
parse_and_accumulate_tokens() {
    local output_file="$1"
    local input_tokens=$({ grep -oE "input[^0-9]*([0-9,]+)" "$output_file" 2>/dev/null || true; } | { grep -oE "[0-9,]+" || true; } | tr -d ',' | tail -1)
    local output_tokens=$({ grep -oE "output[^0-9]*([0-9,]+)" "$output_file" 2>/dev/null || true; } | { grep -oE "[0-9,]+" || true; } | tr -d ',' | tail -1)

    input_tokens=${input_tokens:-0}
    output_tokens=${output_tokens:-0}

    if [ -f "$TOKENS_FILE" ]; then
        local current=$(cat "$TOKENS_FILE")
        local current_input=$(echo "$current" | cut -d'|' -f1)
        local current_output=$(echo "$current" | cut -d'|' -f2)
        [[ "$current_input" =~ ^[0-9]+$ ]] || current_input=0
        [[ "$current_output" =~ ^[0-9]+$ ]] || current_output=0
    else
        current_input=0
        current_output=0
    fi

    local new_input=$((current_input + input_tokens))
    local new_output=$((current_output + output_tokens))
    echo "${new_input}|${new_output}" > "$TOKENS_FILE"
}

# Initialize tokens
init_tokens

FEATURE="${1:?Usage: ./feature-loop.sh <feature-name> [max-iterations] [max-e2e-attempts] [--worktree] [--resume] [--model MODEL]}"
MAX_ITERATIONS="${2:-$DEFAULT_MAX_ITERATIONS}"
MAX_E2E_ATTEMPTS="${3:-$DEFAULT_MAX_E2E}"
ITERATION=0

# Paths
SPEC_FILE="$SPEC_DIR/${FEATURE}.md"
PLAN_FILE="$SPEC_DIR/${FEATURE}-implementation-plan.md"
BRANCH="feat/${FEATURE}"
APP_DIR="$(pwd)"

echo "=========================================="
echo "Ralph Loop: $FEATURE"
echo "Spec: $SPEC_FILE"
echo "Plan: $PLAN_FILE"
echo "Branch: $BRANCH"
echo "App dir: $APP_DIR"
echo "Worktree mode: $USE_WORKTREE"
echo "Resume mode: $RESUME"
echo "Model (planning): $PLANNING_MODEL"
echo "Model (impl): ${MODEL:-$DEFAULT_MODEL}"
echo "Max iterations: $MAX_ITERATIONS"
echo "Max E2E attempts: $MAX_E2E_ATTEMPTS"
echo "=========================================="

# Phase 1: Validate spec exists
if [ ! -f "$SPEC_FILE" ]; then
    echo "ERROR: Spec file not found: $SPEC_FILE"
    echo "Create the spec first: ralph new $FEATURE"
    exit 1
fi

# Phase 2: Create branch if not exists
CURRENT_BRANCH=$(git branch --show-current)
if [ "$CURRENT_BRANCH" != "$BRANCH" ]; then
    if git rev-parse --verify "$BRANCH" >/dev/null 2>&1; then
        if [ "$RESUME" = true ]; then
            echo "Resuming on existing branch: $BRANCH"
            git checkout "$BRANCH"
        else
            echo "Creating/switching to branch: $BRANCH"
            git checkout -B "$BRANCH" main 2>/dev/null || git checkout -B "$BRANCH" master
        fi
    else
        echo "Creating branch: $BRANCH"
        git checkout -b "$BRANCH" main 2>/dev/null || git checkout -b "$BRANCH" master
    fi
else
    echo "Already on branch: $BRANCH"
fi

# Create output file for monitoring
touch "$CLAUDE_OUTPUT"

# Phase 3: Planning (if no implementation plan exists)
if [ ! -f "$PLAN_FILE" ]; then
    echo "======================== PLANNING PHASE ========================"
    export FEATURE APP_DIR SPEC_DIR PROMPTS_DIR
    cat "$PROMPTS_DIR/PROMPT_feature.md" | envsubst | $CLAUDE_CMD_OPUS 2>&1 | tee "$CLAUDE_OUTPUT" || {
        echo "ERROR: Planning phase failed"
        exit 1
    }
    parse_and_accumulate_tokens "$CLAUDE_OUTPUT"
fi

# Phase 4: Implementation loop
echo "======================== IMPLEMENTATION PHASE ========================"
while true; do
    if [ $ITERATION -ge $MAX_ITERATIONS ]; then
        echo "Reached max iterations: $MAX_ITERATIONS"
        exit 1
    fi

    ITERATION=$((ITERATION + 1))
    echo "$ITERATION|$MAX_ITERATIONS|$(date +%s)" > "$STATUS_FILE"
    echo "------------------------ Iteration $ITERATION ------------------------"

    # Check if implementation tasks are done
    PENDING_IMPL=$({ grep "^- \[ \]" "$PLAN_FILE" 2>/dev/null || true; } | { grep -v "E2E:" || true; } | wc -l | tr -d ' ')
    if [ "$PENDING_IMPL" -eq 0 ]; then
        echo "All implementation tasks completed!"
        break
    fi

    echo "Pending implementation tasks: $PENDING_IMPL"
    export FEATURE APP_DIR SPEC_DIR PROMPTS_DIR
    cat "$PROMPTS_DIR/PROMPT.md" | envsubst | $CLAUDE_CMD_IMPL 2>&1 | tee "$CLAUDE_OUTPUT" || true
    parse_and_accumulate_tokens "$CLAUDE_OUTPUT"

    sleep 2
done

# Phase 5: E2E Testing
echo "======================== E2E TESTING PHASE ========================"
E2E_TOTAL=$({ grep "^- \[.\].*E2E:" "$PLAN_FILE" 2>/dev/null || true; } | wc -l | tr -d ' ')
if [ "$E2E_TOTAL" -eq 0 ]; then
    echo "No E2E scenarios defined, skipping E2E phase."
else
    E2E_ATTEMPT=0
    while [ $E2E_ATTEMPT -lt $MAX_E2E_ATTEMPTS ]; do
        E2E_ATTEMPT=$((E2E_ATTEMPT + 1))
        echo "------------------------ E2E Attempt $E2E_ATTEMPT of $MAX_E2E_ATTEMPTS ------------------------"

        export FEATURE APP_DIR SPEC_DIR PROMPTS_DIR
        cat "$PROMPTS_DIR/PROMPT_e2e.md" | envsubst | $CLAUDE_CMD_IMPL 2>&1 | tee "$CLAUDE_OUTPUT" || true
        parse_and_accumulate_tokens "$CLAUDE_OUTPUT"

        # Check if all E2E tests passed
        E2E_FAILED=$({ grep "^- \[ \].*E2E:.*FAILED" "$PLAN_FILE" 2>/dev/null || true; } | wc -l | tr -d ' ')
        E2E_PENDING=$({ grep "^- \[ \].*E2E:" "$PLAN_FILE" 2>/dev/null || true; } | { grep -v "FAILED" || true; } | wc -l | tr -d ' ')

        if [ "$E2E_FAILED" -eq 0 ] && [ "$E2E_PENDING" -eq 0 ]; then
            echo "All E2E tests passed!"
            break
        fi

        if [ $E2E_ATTEMPT -lt $MAX_E2E_ATTEMPTS ]; then
            echo "E2E tests have failures. Running fix iteration..."
            cat "$PROMPTS_DIR/PROMPT.md" | envsubst | $CLAUDE_CMD_IMPL 2>&1 | tee "$CLAUDE_OUTPUT" || true
            parse_and_accumulate_tokens "$CLAUDE_OUTPUT"
        fi
    done
fi

# Phase 6: Spec Verification
echo "======================== SPEC VERIFICATION PHASE ========================"
export FEATURE APP_DIR SPEC_DIR PROMPTS_DIR
cat "$PROMPTS_DIR/PROMPT_verify.md" | envsubst | $CLAUDE_CMD_OPUS 2>&1 | tee "$CLAUDE_OUTPUT" || true
parse_and_accumulate_tokens "$CLAUDE_OUTPUT"

# Phase 7: PR and Review
echo "======================== PR & REVIEW PHASE ========================"
export FEATURE APP_DIR SPEC_DIR PROMPTS_DIR
cat "$PROMPTS_DIR/PROMPT_review.md" | envsubst | $CLAUDE_CMD_OPUS 2>&1 | tee "$CLAUDE_OUTPUT" || true
parse_and_accumulate_tokens "$CLAUDE_OUTPUT"

# Persist final status for TUI summaries
echo "$ITERATION|$MAX_ITERATIONS|$(date +%s)|done" > "$FINAL_STATUS_FILE" 2>/dev/null || true

# Cleanup temp files
rm -f "$STATUS_FILE" 2>/dev/null || true
rm -f "/tmp/ralph-loop-${FEATURE}.output" 2>/dev/null || true

# Print final token usage
if [ -f "/tmp/ralph-loop-${FEATURE}.tokens" ]; then
    echo ""
    echo "=========================================="
    echo "Final Token Usage:"
    cat "/tmp/ralph-loop-${FEATURE}.tokens" | awk -F'|' '{printf "  Input: %s tokens\n  Output: %s tokens\n  Total: %s tokens\n", $1, $2, $1+$2}'
    echo "=========================================="
fi

echo "=========================================="
echo "Ralph loop completed: $FEATURE"
echo "=========================================="
