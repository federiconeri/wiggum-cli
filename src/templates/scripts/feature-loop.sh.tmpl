#!/bin/bash
# feature-loop.sh - Full feature workflow: branch -> implement -> E2E test -> PR -> review -> merge
# Generated by ralph-cli for {{projectName}}
# Usage: ./feature-loop.sh <feature-name> [max-iterations] [max-e2e-attempts] [--worktree] [--resume] [--model MODEL] [--review-mode MODE]
#
# Options:
#   --worktree           Use git worktree for isolation (enables parallel execution)
#   --resume             Resume an interrupted loop (reuses existing branch/worktree)
#   --model MODEL        Claude model to use (e.g., opus, sonnet, claude-sonnet-4-5-20250929)
#   --review-mode MODE   Review mode: 'manual' (stop at PR) or 'auto' (review + merge). Default: 'manual'

set -e
set -o pipefail

# Get script directory
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# Load config from ralph.config.cjs if available
if [ -f "$SCRIPT_DIR/../ralph.config.cjs" ]; then
    RALPH_ROOT=$(node -e "console.log(require('$SCRIPT_DIR/../ralph.config.cjs').paths?.root || '.ralph')" 2>/dev/null || echo ".ralph")
    SPEC_DIR=$(node -e "console.log(require('$SCRIPT_DIR/../ralph.config.cjs').paths?.specs || '.ralph/specs')" 2>/dev/null || echo ".ralph/specs")
    PROMPTS_DIR=$(node -e "console.log(require('$SCRIPT_DIR/../ralph.config.cjs').paths?.prompts || '.ralph/prompts')" 2>/dev/null || echo ".ralph/prompts")
    DEFAULT_MODEL=$(node -e "console.log(require('$SCRIPT_DIR/../ralph.config.cjs').loop?.defaultModel || 'sonnet')" 2>/dev/null || echo "sonnet")
    PLANNING_MODEL=$(node -e "console.log(require('$SCRIPT_DIR/../ralph.config.cjs').loop?.planningModel || 'opus')" 2>/dev/null || echo "opus")
    DEFAULT_MAX_ITERATIONS=$(node -e "console.log(require('$SCRIPT_DIR/../ralph.config.cjs').loop?.maxIterations || 10)" 2>/dev/null || echo "10")
    DEFAULT_MAX_E2E=$(node -e "console.log(require('$SCRIPT_DIR/../ralph.config.cjs').loop?.maxE2eAttempts || 5)" 2>/dev/null || echo "5")
elif [ -f "$SCRIPT_DIR/../../ralph.config.cjs" ]; then
    RALPH_ROOT=$(node -e "console.log(require('$SCRIPT_DIR/../../ralph.config.cjs').paths?.root || '.ralph')" 2>/dev/null || echo ".ralph")
    SPEC_DIR=$(node -e "console.log(require('$SCRIPT_DIR/../../ralph.config.cjs').paths?.specs || '.ralph/specs')" 2>/dev/null || echo ".ralph/specs")
    PROMPTS_DIR=$(node -e "console.log(require('$SCRIPT_DIR/../../ralph.config.cjs').paths?.prompts || '.ralph/prompts')" 2>/dev/null || echo ".ralph/prompts")
    DEFAULT_MODEL=$(node -e "console.log(require('$SCRIPT_DIR/../../ralph.config.cjs').loop?.defaultModel || 'sonnet')" 2>/dev/null || echo "sonnet")
    PLANNING_MODEL=$(node -e "console.log(require('$SCRIPT_DIR/../../ralph.config.cjs').loop?.planningModel || 'opus')" 2>/dev/null || echo "opus")
    DEFAULT_MAX_ITERATIONS=$(node -e "console.log(require('$SCRIPT_DIR/../../ralph.config.cjs').loop?.maxIterations || 10)" 2>/dev/null || echo "10")
    DEFAULT_MAX_E2E=$(node -e "console.log(require('$SCRIPT_DIR/../../ralph.config.cjs').loop?.maxE2eAttempts || 5)" 2>/dev/null || echo "5")
else
    # Default paths
    RALPH_ROOT=".ralph"
    SPEC_DIR=".ralph/specs"
    PROMPTS_DIR=".ralph/prompts"
    DEFAULT_MODEL="sonnet"
    PLANNING_MODEL="opus"
    DEFAULT_MAX_ITERATIONS="10"
    DEFAULT_MAX_E2E="5"
fi

# Navigate to project root (parent of .ralph)
cd "$SCRIPT_DIR/../.."

# Parse arguments
USE_WORKTREE=false
RESUME=false
MODEL=""
REVIEW_MODE=""
POSITIONAL=()
while [[ $# -gt 0 ]]; do
    case $1 in
        --worktree)
            USE_WORKTREE=true
            shift
            ;;
        --resume)
            RESUME=true
            shift
            ;;
        --model)
            MODEL="$2"
            shift 2
            ;;
        --review-mode)
            REVIEW_MODE="$2"
            shift 2
            ;;
        *)
            POSITIONAL+=("$1")
            shift
            ;;
    esac
done
set -- "${POSITIONAL[@]}"

# Resolve review mode from CLI > config > default
if [ -z "$REVIEW_MODE" ]; then
    if [ -f "$SCRIPT_DIR/../ralph.config.cjs" ]; then
        REVIEW_MODE_DEFAULT=$(node -e "console.log(require('$SCRIPT_DIR/../ralph.config.cjs').loop?.reviewMode || 'manual')" 2>/dev/null || echo "manual")
    elif [ -f "$SCRIPT_DIR/../../ralph.config.cjs" ]; then
        REVIEW_MODE_DEFAULT=$(node -e "console.log(require('$SCRIPT_DIR/../../ralph.config.cjs').loop?.reviewMode || 'manual')" 2>/dev/null || echo "manual")
    else
        REVIEW_MODE_DEFAULT="manual"
    fi
    REVIEW_MODE="${REVIEW_MODE_DEFAULT}"
fi

# Validate review mode
if [ "$REVIEW_MODE" != "manual" ] && [ "$REVIEW_MODE" != "auto" ]; then
    echo "ERROR: Invalid review mode: '$REVIEW_MODE'. Allowed values are 'manual' or 'auto'." >&2
    exit 1
fi

# Build claude commands
CLAUDE_CMD_OPUS="claude -p --dangerously-skip-permissions --model ${PLANNING_MODEL}"
CLAUDE_CMD_IMPL="claude -p --dangerously-skip-permissions --model ${MODEL:-$DEFAULT_MODEL}"

# Token tracking
TOKENS_FILE="/tmp/ralph-loop-${1}.tokens"
CLAUDE_OUTPUT="/tmp/ralph-loop-${1}.output"
STATUS_FILE="/tmp/ralph-loop-${1}.status"
FINAL_STATUS_FILE="/tmp/ralph-loop-${1}.final"
PHASES_FILE="/tmp/ralph-loop-${1}.phases"
BASELINE_FILE="/tmp/ralph-loop-${1}.baseline"

# Initialize token tracking
init_tokens() {
    echo "0|0" > "$TOKENS_FILE"
}

# Parse and accumulate tokens
parse_and_accumulate_tokens() {
    local output_file="$1"
    local input_tokens=$({ grep -oE "input[^0-9]*([0-9,]+)" "$output_file" 2>/dev/null || true; } | { grep -oE "[0-9,]+" || true; } | tr -d ',' | tail -1)
    local output_tokens=$({ grep -oE "output[^0-9]*([0-9,]+)" "$output_file" 2>/dev/null || true; } | { grep -oE "[0-9,]+" || true; } | tr -d ',' | tail -1)

    input_tokens=${input_tokens:-0}
    output_tokens=${output_tokens:-0}

    if [ -f "$TOKENS_FILE" ]; then
        local current=$(cat "$TOKENS_FILE")
        local current_input=$(echo "$current" | cut -d'|' -f1)
        local current_output=$(echo "$current" | cut -d'|' -f2)
        [[ "$current_input" =~ ^[0-9]+$ ]] || current_input=0
        [[ "$current_output" =~ ^[0-9]+$ ]] || current_output=0
    else
        current_input=0
        current_output=0
    fi

    local new_input=$((current_input + input_tokens))
    local new_output=$((current_output + output_tokens))
    echo "${new_input}|${new_output}" > "$TOKENS_FILE"
}

# Initialize tokens
init_tokens

# Phase tracking helpers
write_phase_start() {
    local phase_id="$1"
    local timestamp=$(date +%s)
    echo "${phase_id}|started|${timestamp}|" >> "$PHASES_FILE"
}

write_phase_end() {
    local phase_id="$1"
    local status="$2"  # success, failed, skipped
    local timestamp=$(date +%s)

    # Find the last line for this phase and update it
    if [ -f "$PHASES_FILE" ]; then
        # Get all lines except the last matching phase line
        grep -v "^${phase_id}|started|" "$PHASES_FILE" > "${PHASES_FILE}.tmp" 2>/dev/null || true
        # Find the start timestamp from the original file
        local start_ts=$(grep "^${phase_id}|started|" "$PHASES_FILE" | tail -1 | cut -d'|' -f3)
        # Write updated line
        echo "${phase_id}|${status}|${start_ts}|${timestamp}" >> "${PHASES_FILE}.tmp"
        mv "${PHASES_FILE}.tmp" "$PHASES_FILE"
    fi
}

# Initialize phase tracking
> "$PHASES_FILE"

FEATURE="${1:?Usage: ./feature-loop.sh <feature-name> [max-iterations] [max-e2e-attempts] [--worktree] [--resume] [--model MODEL]}"
MAX_ITERATIONS="${2:-$DEFAULT_MAX_ITERATIONS}"
MAX_E2E_ATTEMPTS="${3:-$DEFAULT_MAX_E2E}"
ITERATION=0

# Paths
SPEC_FILE="$SPEC_DIR/${FEATURE}.md"
PLAN_FILE="$SPEC_DIR/${FEATURE}-implementation-plan.md"
BRANCH="feat/${FEATURE}"
APP_DIR="$(pwd)"

echo "=========================================="
echo "Ralph Loop: $FEATURE"
echo "Spec: $SPEC_FILE"
echo "Plan: $PLAN_FILE"
echo "Branch: $BRANCH"
echo "App dir: $APP_DIR"
echo "Worktree mode: $USE_WORKTREE"
echo "Resume mode: $RESUME"
echo "Review mode: $REVIEW_MODE"
echo "Model (planning): $PLANNING_MODEL"
echo "Model (impl): ${MODEL:-$DEFAULT_MODEL}"
echo "Max iterations: $MAX_ITERATIONS"
echo "Max E2E attempts: $MAX_E2E_ATTEMPTS"
echo "=========================================="

# Phase 1: Validate spec exists
if [ ! -f "$SPEC_FILE" ]; then
    echo "ERROR: Spec file not found: $SPEC_FILE"
    echo "Create the spec first: ralph new $FEATURE"
    exit 1
fi

# Phase 2: Create branch if not exists
CURRENT_BRANCH=$(git branch --show-current)
if [ "$CURRENT_BRANCH" != "$BRANCH" ]; then
    if git rev-parse --verify "$BRANCH" >/dev/null 2>&1; then
        if [ "$RESUME" = true ]; then
            echo "Resuming on existing branch: $BRANCH"
            git checkout "$BRANCH"
        else
            echo "Creating/switching to branch: $BRANCH"
            git checkout -B "$BRANCH" main 2>/dev/null || git checkout -B "$BRANCH" master
        fi
    else
        echo "Creating branch: $BRANCH"
        git checkout -b "$BRANCH" main 2>/dev/null || git checkout -b "$BRANCH" master
    fi
else
    echo "Already on branch: $BRANCH"
fi

# Create output file for monitoring
touch "$CLAUDE_OUTPUT"

# Record baseline commit
if git rev-parse --git-dir > /dev/null 2>&1; then
    BASELINE_COMMIT=$(git rev-parse HEAD 2>/dev/null || echo "")
    if [ -n "$BASELINE_COMMIT" ]; then
        echo "$BASELINE_COMMIT" > "$BASELINE_FILE"
        echo "Baseline commit: $BASELINE_COMMIT"
    fi
fi

# Phase 3: Planning (if no implementation plan exists)
if [ ! -f "$PLAN_FILE" ]; then
    echo "======================== PLANNING PHASE ========================"
    write_phase_start "planning"
    export FEATURE APP_DIR SPEC_DIR PROMPTS_DIR
    cat "$PROMPTS_DIR/PROMPT_feature.md" | envsubst | $CLAUDE_CMD_OPUS 2>&1 | tee "$CLAUDE_OUTPUT" || {
        echo "ERROR: Planning phase failed"
        write_phase_end "planning" "failed"
        exit 1
    }
    parse_and_accumulate_tokens "$CLAUDE_OUTPUT"
    write_phase_end "planning" "success"
else
    echo "Plan file exists, skipping planning phase"
    write_phase_start "planning"
    write_phase_end "planning" "skipped"
fi

# Phase 4: Implementation loop
echo "======================== IMPLEMENTATION PHASE ========================"
write_phase_start "implementation"
IMPL_SUCCESS=true
while true; do
    if [ $ITERATION -ge $MAX_ITERATIONS ]; then
        echo "Reached max iterations: $MAX_ITERATIONS"
        IMPL_SUCCESS=false
        write_phase_end "implementation" "failed"
        exit 1
    fi

    ITERATION=$((ITERATION + 1))
    echo "$ITERATION|$MAX_ITERATIONS|$(date +%s)" > "$STATUS_FILE"
    echo "------------------------ Iteration $ITERATION ------------------------"

    # Check if implementation tasks are done
    PENDING_IMPL=$({ grep "^- \[ \]" "$PLAN_FILE" 2>/dev/null || true; } | { grep -v "E2E:" || true; } | wc -l | tr -d ' ')
    if [ "$PENDING_IMPL" -eq 0 ]; then
        echo "All implementation tasks completed!"
        break
    fi

    echo "Pending implementation tasks: $PENDING_IMPL"
    export FEATURE APP_DIR SPEC_DIR PROMPTS_DIR
    cat "$PROMPTS_DIR/PROMPT.md" | envsubst | $CLAUDE_CMD_IMPL 2>&1 | tee "$CLAUDE_OUTPUT" || true
    parse_and_accumulate_tokens "$CLAUDE_OUTPUT"

    sleep 2
done
if [ "$IMPL_SUCCESS" = true ]; then
    write_phase_end "implementation" "success"
fi

# Phase 5: E2E Testing
echo "======================== E2E TESTING PHASE ========================"
E2E_TOTAL=$({ grep "^- \[.\].*E2E:" "$PLAN_FILE" 2>/dev/null || true; } | wc -l | tr -d ' ')
if [ "$E2E_TOTAL" -eq 0 ]; then
    echo "No E2E scenarios defined, skipping E2E phase."
    write_phase_start "e2e_testing"
    write_phase_end "e2e_testing" "skipped"
else
    write_phase_start "e2e_testing"
    E2E_SUCCESS=false
    E2E_ATTEMPT=0
    while [ $E2E_ATTEMPT -lt $MAX_E2E_ATTEMPTS ]; do
        E2E_ATTEMPT=$((E2E_ATTEMPT + 1))
        echo "------------------------ E2E Attempt $E2E_ATTEMPT of $MAX_E2E_ATTEMPTS ------------------------"

        export FEATURE APP_DIR SPEC_DIR PROMPTS_DIR
        cat "$PROMPTS_DIR/PROMPT_e2e.md" | envsubst | $CLAUDE_CMD_IMPL 2>&1 | tee "$CLAUDE_OUTPUT" || true
        parse_and_accumulate_tokens "$CLAUDE_OUTPUT"

        # Check if all E2E tests passed
        E2E_FAILED=$({ grep "^- \[ \].*E2E:.*FAILED" "$PLAN_FILE" 2>/dev/null || true; } | wc -l | tr -d ' ')
        E2E_PENDING=$({ grep "^- \[ \].*E2E:" "$PLAN_FILE" 2>/dev/null || true; } | { grep -v "FAILED" || true; } | wc -l | tr -d ' ')

        if [ "$E2E_FAILED" -eq 0 ] && [ "$E2E_PENDING" -eq 0 ]; then
            echo "All E2E tests passed!"
            E2E_SUCCESS=true
            break
        fi

        if [ $E2E_ATTEMPT -lt $MAX_E2E_ATTEMPTS ]; then
            echo "E2E tests have failures. Running fix iteration..."
            cat "$PROMPTS_DIR/PROMPT.md" | envsubst | $CLAUDE_CMD_IMPL 2>&1 | tee "$CLAUDE_OUTPUT" || true
            parse_and_accumulate_tokens "$CLAUDE_OUTPUT"
        fi
    done

    if [ "$E2E_SUCCESS" = true ]; then
        write_phase_end "e2e_testing" "success"
    else
        write_phase_end "e2e_testing" "failed"
    fi
fi

# Phase 6: Spec Verification
echo "======================== SPEC VERIFICATION PHASE ========================"
write_phase_start "verification"
export FEATURE APP_DIR SPEC_DIR PROMPTS_DIR
VERIFY_STATUS="success"
if ! cat "$PROMPTS_DIR/PROMPT_verify.md" | envsubst | $CLAUDE_CMD_OPUS 2>&1 | tee "$CLAUDE_OUTPUT"; then
    VERIFY_STATUS="failed"
fi
parse_and_accumulate_tokens "$CLAUDE_OUTPUT"
write_phase_end "verification" "$VERIFY_STATUS"

# Phase 7: PR and Review
echo "======================== PR & REVIEW PHASE ========================"
write_phase_start "pr_review"
export FEATURE APP_DIR SPEC_DIR PROMPTS_DIR
PR_STATUS="success"
if [ "$REVIEW_MODE" = "manual" ]; then
    if ! cat "$PROMPTS_DIR/PROMPT_review_manual.md" | envsubst | $CLAUDE_CMD_OPUS 2>&1 | tee "$CLAUDE_OUTPUT"; then
        PR_STATUS="failed"
    fi
else
    if ! cat "$PROMPTS_DIR/PROMPT_review_auto.md" | envsubst | $CLAUDE_CMD_OPUS 2>&1 | tee "$CLAUDE_OUTPUT"; then
        PR_STATUS="failed"
    fi
fi
parse_and_accumulate_tokens "$CLAUDE_OUTPUT"
write_phase_end "pr_review" "$PR_STATUS"

# Persist final status for TUI summaries
if ! echo "$ITERATION|$MAX_ITERATIONS|$(date +%s)|done" > "$FINAL_STATUS_FILE"; then
    echo "WARNING: Failed to write final status file: $FINAL_STATUS_FILE" >&2
fi

# Cleanup temp files
rm -f "$STATUS_FILE" 2>/dev/null || true
rm -f "/tmp/ralph-loop-${FEATURE}.output" 2>/dev/null || true

# Print final token usage
if [ -f "/tmp/ralph-loop-${FEATURE}.tokens" ]; then
    echo ""
    echo "=========================================="
    echo "Final Token Usage:"
    cat "/tmp/ralph-loop-${FEATURE}.tokens" | awk -F'|' '{printf "  Input: %s tokens\n  Output: %s tokens\n  Total: %s tokens\n", $1, $2, $1+$2}'
    echo "=========================================="
fi

echo "=========================================="
echo "Ralph loop completed: $FEATURE"
echo "=========================================="
